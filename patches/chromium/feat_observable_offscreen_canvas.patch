From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Benedek Heilig <benecene@gmail.com>
Date: Mon, 12 Dec 2022 13:34:32 +0100
Subject: feat: observable offscreen canvas

This patch adds the ability to produce textures from OffscreenCanvas
instances.

diff --git a/content/browser/browser_interface_binders.cc b/content/browser/browser_interface_binders.cc
index c3dd39d4887160779d6fee761111ea21cb77a0cf..30d1e58e51994f8781514922ed268c0b0ac100da 100644
--- a/content/browser/browser_interface_binders.cc
+++ b/content/browser/browser_interface_binders.cc
@@ -73,6 +73,8 @@
 #include "device/gamepad/public/mojom/gamepad.mojom.h"
 #include "device/vr/buildflags/buildflags.h"
 #include "device/vr/public/mojom/vr_service.mojom.h"
+#include "electron/shell/common/api/api.mojom.h"
+#include "electron/shell/browser/electron_offscreen_canvas_producer.h"
 #include "media/capture/mojom/image_capture.mojom.h"
 #include "media/capture/mojom/video_capture.mojom.h"
 #include "media/mojo/mojom/interface_factory.mojom.h"
@@ -724,6 +726,9 @@ void PopulateFrameBinders(RenderFrameHostImpl* host, mojo::BinderMap* map) {
   map->Add<device::mojom::BatteryMonitor>(
       base::BindRepeating(&BindBatteryMonitor, base::Unretained(host)));

+  map->Add<electron::mojom::OffscreenCanvasTextureProducer>(
+      base::BindRepeating(&electron::OffscreenCanvasProducer::Create));
+
   map->Add<blink::mojom::CacheStorage>(base::BindRepeating(
       &RenderFrameHostImpl::BindCacheStorage, base::Unretained(host)));

diff --git a/third_party/blink/public/mojom/web_feature/web_feature.mojom b/third_party/blink/public/mojom/web_feature/web_feature.mojom
index ef64c5992df0ba0222147e4dae08355f9a2fb827..b95a72de3956b3007a6c40aea5ea172388a21f86 100644
--- a/third_party/blink/public/mojom/web_feature/web_feature.mojom
+++ b/third_party/blink/public/mojom/web_feature/web_feature.mojom
@@ -3494,6 +3494,8 @@ enum WebFeature {
   kMediaCapabilitiesEncodingInfoWebrtc = 4175,
   kUsbDeviceForget = 4176,
   kPartitionedCookies = 4177,
+  kOffscreenCanvasScheduleTexturePaint = 4179,
+  kCanvasScheduleTexturePaint = 4180,

   // Add new features immediately above this line. Don't change assigned
   // numbers of any item, and don't reuse removed slots.
diff --git a/third_party/blink/renderer/core/html/canvas/canvas_rendering_context.cc b/third_party/blink/renderer/core/html/canvas/canvas_rendering_context.cc
index 11e1a489660637403c7c19eab9f4250eb30fc3c9..3aa0d7c8e2fb280ab59995ed155eac3b1c4cc58c 100644
--- a/third_party/blink/renderer/core/html/canvas/canvas_rendering_context.cc
+++ b/third_party/blink/renderer/core/html/canvas/canvas_rendering_context.cc
@@ -65,6 +65,33 @@ void CanvasRenderingContext::Dispose() {
   }
 }

+bool CanvasRenderingContext::SchedulePaintToSharedTexture(
+    TexturePaintedCallback callback) {
+  if (!IsPaintable()) {
+    return false;
+  }
+
+  scoped_refptr<StaticBitmapImage> bitmap = GetImage();
+  if (!bitmap || !bitmap->IsValid() || !IsAccelerated())
+    return false;
+  bitmap->EnsureSyncTokenVerified();
+
+  // Before discarding the image resource, we need to flush pending render ops
+  // to fully resolve the snapshot.
+  bitmap->PaintImageForCurrentFrame().FlushPendingSkiaOps();
+
+  gpu::SyncToken sync_token = bitmap->GenSyncToken();
+  gfx::Size size = bitmap->Size();
+
+  bitmap->Transfer();
+  std::move(callback).Run(
+      std::move(bitmap),
+      std::move(sync_token),
+      gfx::Rect(size));
+
+   return true;
+}
+
 NoAllocDirectCallHost* CanvasRenderingContext::AsNoAllocDirectCallHost() {
   return nullptr;
 }
diff --git a/third_party/blink/renderer/core/html/canvas/canvas_rendering_context.h b/third_party/blink/renderer/core/html/canvas/canvas_rendering_context.h
index 7afd1a94b5f97a9fb7a6692cbb1b476948169d49..c7d6ab1e52f7dceb37645bdd8819f6fa64936ffc 100644
--- a/third_party/blink/renderer/core/html/canvas/canvas_rendering_context.h
+++ b/third_party/blink/renderer/core/html/canvas/canvas_rendering_context.h
@@ -26,6 +26,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_CORE_HTML_CANVAS_CANVAS_RENDERING_CONTEXT_H_
 #define THIRD_PARTY_BLINK_RENDERER_CORE_HTML_CANVAS_CANVAS_RENDERING_CONTEXT_H_

+#include "gpu/command_buffer/common/sync_token.h"
 #include "third_party/blink/public/common/privacy_budget/identifiable_token.h"
 #include "third_party/blink/renderer/bindings/core/v8/active_script_wrappable.h"
 #include "third_party/blink/renderer/core/core_export.h"
@@ -78,6 +79,11 @@ class CORE_EXPORT CanvasRenderingContext
     kMaxValue = kWebgpu,
   };

+  using TexturePaintedCallback = base::OnceCallback<void(
+      scoped_refptr<StaticBitmapImage> image,
+      const gpu::SyncToken& sync_token,
+      const gfx::Rect& rect)>;
+
   CanvasRenderingAPI GetRenderingAPI() const { return canvas_rendering_type_; }

   bool IsRenderingContext2D() const {
@@ -124,6 +130,7 @@ class CORE_EXPORT CanvasRenderingContext
   CanvasRenderingContextHost* Host() const { return host_; }
   SkColorInfo CanvasRenderingContextSkColorInfo() const;

+  virtual bool SchedulePaintToSharedTexture(TexturePaintedCallback callback);
   virtual scoped_refptr<StaticBitmapImage> GetImage() = 0;
   virtual bool IsComposited() const = 0;
   virtual bool IsAccelerated() const = 0;
diff --git a/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc b/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc
index 1867d0bbd802b4e8942a3a2e5d2e1234b14c30ec..273bcfff8dd08331b24c755430026559988cc49f 100644
--- a/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc
+++ b/third_party/blink/renderer/core/html/canvas/html_canvas_element.cc
@@ -40,6 +40,8 @@
 #include "base/numerics/checked_math.h"
 #include "base/numerics/safe_conversions.h"
 #include "build/build_config.h"
+#include "components/viz/common/resources/single_release_callback.h"
+#include "mojo/public/cpp/bindings/self_owned_receiver.h"
 #include "services/metrics/public/cpp/ukm_recorder.h"
 #include "services/metrics/public/cpp/ukm_source_id.h"
 #include "third_party/blink/public/common/features.h"
@@ -105,6 +107,7 @@
 #include "third_party/blink/renderer/platform/instrumentation/use_counter.h"
 #include "third_party/blink/renderer/platform/privacy_budget/identifiability_digest_helpers.h"
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
+#include "third_party/blink/renderer/platform/wtf/functional.h"
 #include "ui/base/resource/resource_scale_factor.h"
 #include "ui/gfx/geometry/skia_conversions.h"
 #include "v8/include/v8.h"
@@ -170,6 +173,10 @@ HTMLCanvasElement::HTMLCanvasElement(Document& document)
   if (execution_context) {
     CanvasResourceTracker::For(execution_context->GetIsolate())
         ->Add(this, execution_context);
+
+    execution_context->GetBrowserInterfaceBroker().GetInterface(
+        texture_producer_.BindNewPipeAndPassReceiver(
+            execution_context->GetTaskRunner(TaskType::kInternalDefault)));
   }
 }

@@ -253,6 +260,8 @@ void HTMLCanvasElement::setHeight(unsigned value,
                                kDefaultCanvasHeight);
 }

+void HTMLCanvasElement::setUuid(WTF::String uuid) {}
+
 void HTMLCanvasElement::setWidth(unsigned value,
                                  ExceptionState& exception_state) {
   if (IsOffscreenCanvasRegistered()) {
@@ -450,6 +459,66 @@ ScriptPromise HTMLCanvasElement::convertToBlob(
                                                    exception_state, context_);
 }

+ScriptPromise HTMLCanvasElement::scheduleTexturePaint(
+    ScriptState* script_state, ExceptionState& exception_state) {
+  if (texture_promise_resolver_)
+    return texture_promise_resolver_->Promise();
+
+  ScriptPromiseResolver* resolver =
+    MakeGarbageCollected<ScriptPromiseResolver>(script_state);
+  ScriptPromise promise = resolver->Promise();
+  texture_promise_resolver_ = resolver;
+
+  if (context_) {
+    bool success = context_->SchedulePaintToSharedTexture(WTF::Bind(
+        &HTMLCanvasElement::OnTexturePaint,
+        WrapPersistent(this),
+        WrapPersistent(resolver)));
+
+    if (!success) {
+      resolver->Reject();
+    }
+    return promise;
+  }
+
+  resolver->Reject();
+  return promise;
+}
+
+void HTMLCanvasElement::TexturePaintDone(
+    ScriptPromiseResolver* resolver,
+    scoped_refptr<StaticBitmapImage> image,
+    const gpu::SyncToken& sync_token,
+    bool is_lost) {
+  resolver->Resolve();
+  texture_promise_resolver_.Clear();
+  // noop, just release image
+}
+
+void HTMLCanvasElement::OnTexturePaint(
+    ScriptPromiseResolver* resolver,
+    scoped_refptr<StaticBitmapImage> image,
+    const gpu::SyncToken& sync_token,
+    const gfx::Rect& rect) {
+  mojo::PendingRemote<::viz::mojom::SingleReleaseCallback> callback;
+  gpu::MailboxHolder mailbox_holder = image->GetMailboxHolder();
+
+  mojo::MakeSelfOwnedReceiver(
+      viz::SingleReleaseCallback::Create(WTF::Bind(
+          &HTMLCanvasElement::TexturePaintDone,
+          WrapPersistent(this),
+          WrapPersistent(resolver),
+          std::move(image))),
+      callback.InitWithNewPipeAndPassReceiver());
+
+  texture_producer_->OnTextureProduced(
+      uuid_.Ascii(),
+      std::move(mailbox_holder.mailbox),
+      std::move(sync_token),
+      rect,
+      std::move(callback));
+}
+
 bool HTMLCanvasElement::ShouldBeDirectComposited() const {
   return (context_ && context_->IsComposited()) || (!!surface_layer_bridge_);
 }
@@ -1288,6 +1357,7 @@ void HTMLCanvasElement::NotifyGpuContextLost() {
 void HTMLCanvasElement::Trace(Visitor* visitor) const {
   visitor->Trace(listeners_);
   visitor->Trace(context_);
+  visitor->Trace(texture_promise_resolver_);
   ExecutionContextLifecycleObserver::Trace(visitor);
   PageVisibilityObserver::Trace(visitor);
   HTMLElement::Trace(visitor);
diff --git a/third_party/blink/renderer/core/html/canvas/html_canvas_element.h b/third_party/blink/renderer/core/html/canvas/html_canvas_element.h
index 04db64522edb5296ed9b0ca73525519a6e6739eb..45f4d43ab0c08957994c51e6a6507db4c9086757 100644
--- a/third_party/blink/renderer/core/html/canvas/html_canvas_element.h
+++ b/third_party/blink/renderer/core/html/canvas/html_canvas_element.h
@@ -32,6 +32,7 @@

 #include "base/memory/weak_ptr.h"
 #include "base/task/single_thread_task_runner.h"
+#include "electron/shell/common/api/api.mojom.h"
 #include "third_party/blink/public/common/privacy_budget/identifiable_surface.h"
 #include "third_party/blink/public/common/privacy_budget/identifiable_token.h"
 #include "third_party/blink/renderer/bindings/core/v8/script_value.h"
@@ -104,11 +105,13 @@ class CORE_EXPORT HTMLCanvasElement final
   // Attributes and functions exposed to script
   unsigned width() const { return Size().width(); }
   unsigned height() const { return Size().height(); }
+  WTF::String uuid() const { return uuid_; }

   const gfx::Size& Size() const override { return size_; }

   void setWidth(unsigned, ExceptionState&);
   void setHeight(unsigned, ExceptionState&);
+  void setUuid(WTF::String);

   void SetSize(const gfx::Size& new_size);

@@ -294,6 +297,18 @@ class CORE_EXPORT HTMLCanvasElement final
                               const ImageEncodeOptions*,
                               ExceptionState&);

+  ScriptPromise scheduleTexturePaint(ScriptState*, ExceptionState&);
+  void TexturePaintDone(
+      ScriptPromiseResolver* resolver,
+      scoped_refptr<StaticBitmapImage> image,
+      const gpu::SyncToken& sync_token,
+      bool is_lost);
+  void OnTexturePaint(
+      ScriptPromiseResolver* resolver,
+      scoped_refptr<StaticBitmapImage> image,
+      const gpu::SyncToken& sync_token,
+      const gfx::Rect& rect);
+
   bool NeedsUnbufferedInputEvents() const { return needs_unbuffered_input_; }

   void SetNeedsUnbufferedInputEvents(bool value) {
@@ -418,6 +433,10 @@ class CORE_EXPORT HTMLCanvasElement final
   mutable intptr_t externally_allocated_memory_;

   scoped_refptr<StaticBitmapImage> transparent_image_;
+
+  WTF::String uuid_;
+  mojo::Remote<::electron::mojom::OffscreenCanvasTextureProducer> texture_producer_;
+  Member<ScriptPromiseResolver> texture_promise_resolver_;
 };

 }  // namespace blink
diff --git a/third_party/blink/renderer/core/html/canvas/html_canvas_element.idl b/third_party/blink/renderer/core/html/canvas/html_canvas_element.idl
index 3a6ff316fd3971fe47e9afffada3057c4aa80645..e801972f31f8937c48d6c066e68d614f9c779e9a 100644
--- a/third_party/blink/renderer/core/html/canvas/html_canvas_element.idl
+++ b/third_party/blink/renderer/core/html/canvas/html_canvas_element.idl
@@ -35,12 +35,15 @@

     [RaisesException=Setter, CEReactions] attribute unsigned long width;
     [RaisesException=Setter, CEReactions] attribute unsigned long height;
+    attribute DOMString uuid;

     [HighEntropy, MeasureAs=CanvasToDataURL, RaisesException] DOMString toDataURL(optional DOMString type = "image/png", optional any quality);

     [HighEntropy, MeasureAs=CanvasToBlob, RaisesException] void toBlob(BlobCallback _callback, optional DOMString type = "image/png", optional any quality);

     [HighEntropy, RuntimeEnabled=CanvasColorManagementV2, MeasureAs=CanvasConvertToBlob, RaisesException, CallWith=ScriptState] Promise<Blob> convertToBlob(optional ImageEncodeOptions options = {});
+
+    [HighEntropy, MeasureAs=CanvasScheduleTexturePaint, RaisesException, CallWith=ScriptState] Promise<void> scheduleTexturePaint();
 };

 // https://html.spec.whatwg.org/C/#blobcallback
diff --git a/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.cc b/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.cc
index 584920aad8a3bfd9f00bf0db99fdf1891b13176b..7f562b6ce740e1a204ec90944e479b3f938c7963 100644
--- a/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.cc
+++ b/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.cc
@@ -6,9 +6,12 @@

 #include <memory>
 #include <utility>
+#include <random>

 #include "base/metrics/histogram_functions.h"
 #include "base/numerics/safe_conversions.h"
+#include "components/viz/common/resources/single_release_callback.h"
+#include "mojo/public/cpp/bindings/self_owned_receiver.h"
 #include "third_party/blink/public/common/privacy_budget/identifiability_metric_builder.h"
 #include "third_party/blink/public/common/privacy_budget/identifiability_metrics.h"
 #include "third_party/blink/public/common/privacy_budget/identifiability_study_settings.h"
@@ -45,17 +48,22 @@
 #include "third_party/blink/renderer/platform/instrumentation/histogram.h"
 #include "third_party/blink/renderer/platform/instrumentation/tracing/trace_event.h"
 #include "third_party/blink/renderer/platform/instrumentation/use_counter.h"
+#include "third_party/blink/renderer/platform/wtf/functional.h"
 #include "third_party/blink/renderer/platform/wtf/math_extras.h"
 #include "third_party/skia/include/core/SkSurface.h"

 namespace blink {

+[[clang::no_destroy]]
+OffscreenCanvas::uuid_generator OffscreenCanvas::gen;
+
 OffscreenCanvas::OffscreenCanvas(ExecutionContext* context,
                                  const gfx::Size& size)
     : CanvasRenderingContextHost(
           CanvasRenderingContextHost::HostType::kOffscreenCanvasHost),
       execution_context_(context),
-      size_(size) {
+      size_(size),
+      uuid_(generateUUID()) {
   // Other code in Blink watches for destruction of the context; be
   // robust here as well.
   if (!context->IsContextDestroyed()) {
@@ -75,6 +83,10 @@ OffscreenCanvas::OffscreenCanvas(ExecutionContext* context,
       // itself cross-origin.
       AllowHighPerformancePowerPreference();
     }
+
+    context->GetBrowserInterfaceBroker().GetInterface(
+        texture_producer_.BindNewPipeAndPassReceiver(
+            context->GetTaskRunner(TaskType::kInternalDefault)));
   }

   CanvasResourceTracker::For(context->GetIsolate())->Add(this, context);
@@ -160,6 +172,8 @@ void OffscreenCanvas::setHeight(unsigned height) {
   SetSize(new_size);
 }

+void OffscreenCanvas::setUuid(WTF::String uuid) {}
+
 void OffscreenCanvas::SetSize(const gfx::Size& size) {
   // Setting size of a canvas also resets it.
   if (size == size_) {
@@ -194,6 +208,66 @@ ScriptPromise OffscreenCanvas::convertToBlob(ScriptState* script_state,
                                                    exception_state, context_);
 }

+ScriptPromise OffscreenCanvas::scheduleTexturePaint(
+    ScriptState* script_state, ExceptionState& exception_state) {
+  if (texture_promise_resolver_)
+    return texture_promise_resolver_->Promise();
+
+  ScriptPromiseResolver* resolver =
+    MakeGarbageCollected<ScriptPromiseResolver>(script_state);
+  ScriptPromise promise = resolver->Promise();
+  texture_promise_resolver_ = resolver;
+
+  if (context_) {
+    bool success = context_->SchedulePaintToSharedTexture(WTF::Bind(
+        &OffscreenCanvas::OnTexturePaint,
+        WrapPersistent(this),
+        WrapPersistent(resolver)));
+
+    if (!success) {
+      resolver->Reject();
+    }
+    return promise;
+  }
+
+  resolver->Reject();
+  return promise;
+}
+
+void OffscreenCanvas::TexturePaintDone(
+    ScriptPromiseResolver* resolver,
+    scoped_refptr<StaticBitmapImage> image,
+    const gpu::SyncToken& sync_token,
+    bool is_lost) {
+  resolver->Resolve();
+  texture_promise_resolver_.Clear();
+  // noop, just release image
+}
+
+void OffscreenCanvas::OnTexturePaint(
+    ScriptPromiseResolver* resolver,
+    scoped_refptr<StaticBitmapImage> image,
+    const gpu::SyncToken& sync_token,
+    const gfx::Rect& rect) {
+  mojo::PendingRemote<::viz::mojom::SingleReleaseCallback> callback;
+  gpu::MailboxHolder mailbox_holder = image->GetMailboxHolder();
+
+  mojo::MakeSelfOwnedReceiver(
+      viz::SingleReleaseCallback::Create(WTF::Bind(
+          &OffscreenCanvas::TexturePaintDone,
+          WrapPersistent(this),
+          WrapPersistent(resolver),
+          std::move(image))),
+      callback.InitWithNewPipeAndPassReceiver());
+
+  texture_producer_->OnTextureProduced(
+      uuid_.Ascii(),
+      std::move(mailbox_holder.mailbox),
+      std::move(sync_token),
+      rect,
+      std::move(callback));
+}
+
 void OffscreenCanvas::RecordTransfer() {
   UMA_HISTOGRAM_BOOLEAN("Blink.OffscreenCanvas.Transferred", true);
 }
@@ -354,6 +428,21 @@ CanvasRenderingContextFactory* OffscreenCanvas::GetRenderingContextFactory(
   return RenderingContextFactories()[type].get();
 }

+std::string OffscreenCanvas::generateUUID() {
+  std::uniform_int_distribution<int> dist(0, 15);
+
+  const char *v = "0123456789abcdef";
+  const bool dash[] = { 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0 };
+
+  std::string res;
+  for (int i = 0; i < 16; i++) {
+      if (dash[i]) res += "-";
+      res += v[dist(gen.rng)];
+      res += v[dist(gen.rng)];
+  }
+  return res;
+}
+
 void OffscreenCanvas::RegisterRenderingContextFactory(
     std::unique_ptr<CanvasRenderingContextFactory> rendering_context_factory) {
   CanvasRenderingContext::CanvasRenderingAPI rendering_api =
@@ -602,6 +691,7 @@ size_t OffscreenCanvas::GetMemoryUsage() const {
 void OffscreenCanvas::Trace(Visitor* visitor) const {
   visitor->Trace(context_);
   visitor->Trace(execution_context_);
+  visitor->Trace(texture_promise_resolver_);
   EventTargetWithInlineData::Trace(visitor);
 }

diff --git a/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.h b/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.h
index 99898be4cc87a1cc671f360f9e7d70ce5f625403..1d449ce938977f65afe0e4107a5b7bd8637b145d 100644
--- a/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.h
+++ b/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.h
@@ -7,6 +7,8 @@

 #include <memory>

+#include "electron/shell/common/api/api.mojom.h"
+#include "mojo/public/cpp/bindings/remote.h"
 #include "third_party/blink/public/common/privacy_budget/identifiable_surface.h"
 #include "third_party/blink/public/common/privacy_budget/identifiable_token.h"
 #include "third_party/blink/renderer/bindings/core/v8/script_promise.h"
@@ -20,6 +22,7 @@
 #include "third_party/blink/renderer/platform/graphics/canvas_resource_dispatcher.h"
 #include "third_party/blink/renderer/platform/heap/garbage_collected.h"
 #include "third_party/blink/renderer/platform/heap/prefinalizer.h"
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
 #include "ui/gfx/geometry/size.h"

 namespace blink {
@@ -53,8 +56,10 @@ class CORE_EXPORT OffscreenCanvas final
   // IDL attributes
   unsigned width() const { return size_.width(); }
   unsigned height() const { return size_.height(); }
+  WTF::String uuid() const { return uuid_; }
   void setWidth(unsigned);
   void setHeight(unsigned);
+  void setUuid(WTF::String);

   // CanvasResourceDispatcherClient
   bool BeginFrame() override;
@@ -68,6 +73,17 @@ class CORE_EXPORT OffscreenCanvas final
                               const ImageEncodeOptions* options,
                               ExceptionState& exception_state);

+  ScriptPromise scheduleTexturePaint(ScriptState*, ExceptionState&);
+  void TexturePaintDone(
+      ScriptPromiseResolver* resolver,
+      scoped_refptr<StaticBitmapImage> image,
+      const gpu::SyncToken& sync_token,
+      bool is_lost);
+  void OnTexturePaint(
+      ScriptPromiseResolver* resolver,
+      scoped_refptr<StaticBitmapImage> image,
+      const gpu::SyncToken& sync_token,
+      const gfx::Rect& rect);
   const gfx::Size& Size() const override { return size_; }
   void SetSize(const gfx::Size&);
   void RecordTransfer();
@@ -235,6 +251,19 @@ class CORE_EXPORT OffscreenCanvas final
   static ContextFactoryVector& RenderingContextFactories();
   static CanvasRenderingContextFactory* GetRenderingContextFactory(int);

+  struct uuid_generator {
+    uuid_generator() {
+      rng = std::mt19937(device());
+    }
+
+    std::random_device device;
+    std::mt19937 rng;
+  };
+
+  [[clang::no_destroy]]
+  static uuid_generator gen;
+  static std::string generateUUID();
+
   void RecordIdentifiabilityMetric(const blink::IdentifiableSurface& surface,
                                    const IdentifiableToken& token) const;

@@ -269,6 +298,10 @@ class CORE_EXPORT OffscreenCanvas final
   // then the following members would remain as initialized zero values.
   uint32_t client_id_ = 0;
   uint32_t sink_id_ = 0;
+
+  WTF::String uuid_;
+  mojo::Remote<::electron::mojom::OffscreenCanvasTextureProducer> texture_producer_;
+  Member<ScriptPromiseResolver> texture_promise_resolver_;
 };

 }  // namespace blink
diff --git a/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.idl b/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.idl
index f5821d38f1bf3f3283077d358ea80926db278e5e..d176857672ce4df37079af52148afc40c563f2eb 100644
--- a/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.idl
+++ b/third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.idl
@@ -11,9 +11,11 @@
     [CallWith=ExecutionContext, MeasureAs=OffscreenCanvas] constructor([EnforceRange] unsigned long width, [EnforceRange] unsigned long height);
     attribute [EnforceRange] unsigned long width;
     attribute [EnforceRange] unsigned long height;
+    attribute DOMString uuid;

     [CallWith=ScriptState, HighEntropy, MeasureAs=OffscreenCanvasTransferToImageBitmap, RaisesException] ImageBitmap transferToImageBitmap();
     [CallWith=ScriptState, HighEntropy, MeasureAs=OffscreenCanvasConvertToBlob, RaisesException] Promise<Blob> convertToBlob(optional ImageEncodeOptions options = {});
+    [CallWith=ScriptState, HighEntropy, MeasureAs=OffscreenCanvasScheduleTexturePaint, RaisesException] Promise<void> scheduleTexturePaint();

     [RuntimeEnabled=NewCanvas2DAPI] attribute EventHandler oncontextlost;
     [RuntimeEnabled=NewCanvas2DAPI] attribute EventHandler oncontextrestored;
diff --git a/third_party/blink/renderer/modules/canvas/BUILD.gn b/third_party/blink/renderer/modules/canvas/BUILD.gn
index ca6c394c989d6fdac979ebad983cdecaf7ba240d..4d6a5b74387c0b44708d95fdddf82da14fc59b9b 100644
--- a/third_party/blink/renderer/modules/canvas/BUILD.gn
+++ b/third_party/blink/renderer/modules/canvas/BUILD.gn
@@ -53,7 +53,11 @@ blink_modules_sources("canvas") {
     "offscreencanvas2d/offscreen_canvas_rendering_context_2d.h",
   ]

-  deps = [ "//third_party/blink/renderer/modules/webcodecs" ]
+  deps = [
+    "//third_party/blink/renderer/modules/webcodecs",
+    "//electron/native_api:canvas",
+    "//electron/shell/common/api:mojo",
+  ]
   allow_circular_includes_from =
       [ "//third_party/blink/renderer/modules/webcodecs" ]
 }
diff --git a/third_party/blink/renderer/modules/canvas/offscreencanvas2d/offscreen_canvas_rendering_context_2d.h b/third_party/blink/renderer/modules/canvas/offscreencanvas2d/offscreen_canvas_rendering_context_2d.h
index 354d83c598538a203a844f88963a3c7a0c6a76eb..8747490d4b66a7ecabfd1873ef595d73238634ea 100644
--- a/third_party/blink/renderer/modules/canvas/offscreencanvas2d/offscreen_canvas_rendering_context_2d.h
+++ b/third_party/blink/renderer/modules/canvas/offscreencanvas2d/offscreen_canvas_rendering_context_2d.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_CANVAS_OFFSCREENCANVAS2D_OFFSCREEN_CANVAS_RENDERING_CONTEXT_2D_H_
 #define THIRD_PARTY_BLINK_RENDERER_MODULES_CANVAS_OFFSCREENCANVAS2D_OFFSCREEN_CANVAS_RENDERING_CONTEXT_2D_H_

+#include "electron/native_api/offscreen.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_typedefs.h"
 #include "third_party/blink/renderer/core/html/canvas/canvas_context_creation_attributes_core.h"
 #include "third_party/blink/renderer/core/html/canvas/canvas_rendering_context.h"
diff --git a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
index 6a292e1671637a0fb5a44b7d3f5334ac943237ff..47979489a11743bb409ddcaa0ecd3fcaa981e8b0 100644
--- a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
+++ b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
@@ -622,6 +622,33 @@ void WebGLRenderingContextBase::commit() {
   MarkLayerComposited();
 }

+bool WebGLRenderingContextBase::SchedulePaintToSharedTexture(
+    TexturePaintedCallback callback) {
+  if (!GetDrawingBuffer())
+    return false;
+
+  auto canvas_resource = GetDrawingBuffer()->ExportCanvasResource();
+  if (!canvas_resource)
+    return false;
+  MarkLayerComposited();
+
+  scoped_refptr<StaticBitmapImage> bitmap = canvas_resource->Bitmap();
+  if (!bitmap || !bitmap->IsValid() || !bitmap->IsTextureBacked())
+    return false;
+  bitmap->EnsureSyncTokenVerified();
+
+  gpu::SyncToken sync_token = bitmap->GenSyncToken();
+  gfx::Size size = GetDrawingBuffer()->Size();
+
+  bitmap->Transfer();
+  std::move(callback).Run(
+      std::move(bitmap),
+      std::move(sync_token),
+      gfx::Rect(size));
+
+   return true;
+}
+
 scoped_refptr<StaticBitmapImage> WebGLRenderingContextBase::GetImage() {
   if (!GetDrawingBuffer())
     return nullptr;
diff --git a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.h b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.h
index d1fd5a615200898896783a4a3c874f4dfdd24d3c..92395213c57a38e52d1002d4f969fe1827aad408 100644
--- a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.h
+++ b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.h
@@ -639,6 +639,7 @@ class MODULES_EXPORT WebGLRenderingContextBase : public CanvasRenderingContext,
   CanvasColorParams CanvasRenderingContextColorParams() const override {
     return color_params_;
   }
+  bool SchedulePaintToSharedTexture(TexturePaintedCallback callback) override;
   scoped_refptr<StaticBitmapImage> GetImage() override;
   void SetFilterQuality(cc::PaintFlags::FilterQuality) override;

diff --git a/third_party/blink/renderer/platform/graphics/accelerated_static_bitmap_image.cc b/third_party/blink/renderer/platform/graphics/accelerated_static_bitmap_image.cc
index 71025d4fdf6ca403fbfe1d10163052134e209b7f..deac245c93df06281ea9825b06e32fdb2f1d9ff9 100644
--- a/third_party/blink/renderer/platform/graphics/accelerated_static_bitmap_image.cc
+++ b/third_party/blink/renderer/platform/graphics/accelerated_static_bitmap_image.cc
@@ -157,6 +157,24 @@ bool AcceleratedStaticBitmapImage::CopyToTexture(
   return true;
 }

+gpu::SyncToken AcceleratedStaticBitmapImage::GenSyncToken() {
+  base::WeakPtr<WebGraphicsContext3DProviderWrapper> shared_context_wrapper =
+      SharedGpuContext::ContextProviderWrapper();
+  if (!shared_context_wrapper || !shared_context_wrapper->ContextProvider())
+    return gpu::SyncToken();
+
+  auto* ri = shared_context_wrapper->ContextProvider()->RasterInterface();
+  DCHECK(ri);
+
+  gpu::SyncToken sync_token;
+  int8_t* token_data = sync_token.GetData();
+  ri->GenSyncTokenCHROMIUM(token_data);
+  ri->VerifySyncTokensCHROMIUM(&token_data, 1);
+  sync_token.SetVerifyFlush();
+
+  return sync_token;
+}
+
 bool AcceleratedStaticBitmapImage::CopyToResourceProvider(
     CanvasResourceProvider* resource_provider) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
diff --git a/third_party/blink/renderer/platform/graphics/accelerated_static_bitmap_image.h b/third_party/blink/renderer/platform/graphics/accelerated_static_bitmap_image.h
index 7072de21be5afbf00fe5d3bc549885ef4573a3e5..9e6e66efbbc2a6951d9a213f4f32bf7e40e244b4 100644
--- a/third_party/blink/renderer/platform/graphics/accelerated_static_bitmap_image.h
+++ b/third_party/blink/renderer/platform/graphics/accelerated_static_bitmap_image.h
@@ -96,6 +96,8 @@ class PLATFORM_EXPORT AcceleratedStaticBitmapImage final
                      const gfx::Point& dest_point,
                      const gfx::Rect& source_sub_rectangle) override;

+  gpu::SyncToken GenSyncToken() override;
+
   bool CopyToResourceProvider(
       CanvasResourceProvider* resource_provider) override;

diff --git a/third_party/blink/renderer/platform/graphics/static_bitmap_image.h b/third_party/blink/renderer/platform/graphics/static_bitmap_image.h
index c02381c38b460e29d0b9804c9cf42222d4e65566..276eafee9c9417d5415943c096b00efda5ba3aec 100644
--- a/third_party/blink/renderer/platform/graphics/static_bitmap_image.h
+++ b/third_party/blink/renderer/platform/graphics/static_bitmap_image.h
@@ -7,6 +7,7 @@

 #include "base/memory/weak_ptr.h"
 #include "gpu/command_buffer/common/mailbox_holder.h"
+#include "gpu/command_buffer/common/sync_token.h"
 #include "third_party/blink/renderer/platform/graphics/canvas_color_params.h"
 #include "third_party/blink/renderer/platform/graphics/graphics_types.h"
 #include "third_party/blink/renderer/platform/graphics/image.h"
@@ -76,6 +77,11 @@ class PLATFORM_EXPORT StaticBitmapImage : public Image {
     return false;
   }

+  virtual gpu::SyncToken GenSyncToken() {
+    NOTREACHED();
+    return gpu::SyncToken();
+  }
+
   virtual bool CopyToResourceProvider(CanvasResourceProvider*) {
     NOTREACHED();
     return false;
